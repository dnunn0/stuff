<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="css.css" media="screen"/>
    <title>Firefly</title>
    <script>
    let hostPort = location.hostname + ":" + location.port;
    let isDrawing = false;
    let webSocket = null;
    setupStatus();
    let deck_al = new Deck("/alliance/nav");
    let deck_bo = new Deck("/border/nav");
    let deck_ri = new Deck("/rim/nav");
    let decks = new Map();
    decks.set(deck_al.navPath, deck_al);
    decks.set(deck_bo.navPath, deck_bo);
    decks.set(deck_ri.navPath, deck_ri);
    let dd_al = new DeckDisplay(deck_al);
    let dd_bo = new DeckDisplay(deck_bo);
    let dd_ri = new DeckDisplay(deck_ri);
    let dds = new Map();
    dds.set(deck_al, dd_al);
    dds.set(deck_bo, dd_bo);
    dds.set(deck_ri, dd_ri);

    let actionCheckboxes = ["workCb", "buyCb", "dealCb", "flyCb"];


    function Deck(navPath) {
        this.navPath = navPath;
        this.navLockPath = navPath + "/lock";
        this.specPath = navPath + "/spec";
        this.remainingCardsCount = -1;
        this.discardsCount = -1;
        this.isLocked = false;
        this.hasCards = false;
        this.nextDrawDisabledStatus = false;
        this.shouldShuffle = false;
    }
    Deck.FindAndUpdateFrom = function(statusJsonString) {
        let statusj = JSON.parse(statusJsonString);
        let deckName = statusj.source;
        let deck = decks.get(deckName);
        deck.remainingCardsCount = statusj.remainingCardsCount;
        deck.discardsCount = statusj.discardsCount;
        deck.isLocked = statusj.isLocked;
        deck.hasCards = deck.remainingCardsCount > 0;
        deck.nextDrawDisabledStatus = !deck.hasCards || deck.isLocked;
        deck.shouldShuffle = !(deck.hasCards || deck.isLocked);
        return deck;
    }
    Deck.prototype.matches = function(path) {
        return (this.navPath==path) || (this.navLockPath==path) || (this.specPath==path);
    }


    function Card(deck, action) {
        this.deck = deck;
        this.action = action;
        let cardName = this.action.replace(/[^a-zA-Z]/g, "") + ".png";
        cardName = startWithSlash(cardName);
        this.url = "http://" + hostPort + this.deck.navPath + "Card" + cardName;
    }
    Card.FromJson = function(deck, cardJsonString) {
        let cardj = JSON.parse(cardJsonString);
        return new Card(deck, cardj.action);
    }
    Card.prototype.getAnchor = function(anchorText) {
        return "<a href='" + this.url + "' target='_blank'>" + anchorText + "</a>";
    }

    function DeckDisplay(deck) {
        this.deck = deck;
        this.responseStatusArea = deck.navPath + "/requestResult";
        this.drawBtnId = this.deck.navPath + "/drawBtn";
        this.shuffleBtnId = this.deck.navPath + "/shuffleBtn";
        this.unlockBtnId = this.deck.navPath + "/unlockBtn";
        this.statusId = this.deck.navPath + "/status";
        this.specAreaId = this.deck.navPath + "/spec";
    }
    DeckDisplay.updateStatus = function(msg) {
        let deck = Deck.FindAndUpdateFrom(msg.data);
        let displayDeck = dds.get(deck);
        displayDeck.reportStatus();
        displayDeck.applyStatus();
    }
    DeckDisplay.prototype.reportError = function(message) {
        updateElement(this.responseStatusArea, true, message);
    }
    DeckDisplay.prototype.reportUnexpectedError = function(xhttp) {
        let result = "Unexpected error: ReadyState, status, text: " + xhttp.readyState + "- " + xhttp.status + "-" +
            xhttp.statusText + ".";
        this.reportError(result);
    }
    DeckDisplay.prototype.updateResponse = function(message) {
        updateElement(this.responseStatusArea, false, message);
    }
    DeckDisplay.prototype.disableDrawCardButton = function(newState) {
        let control = document.getElementById(this.drawBtnId);
        if (newState) control.classList.add('disabled');
        else control.classList.remove('disabled');
    }
    DeckDisplay.prototype.applyNextDrawDisabledStatus = function() {
        //TODO how to make private methods (and then can make disable(id) private too)
        this.disableDrawCardButton(this.deck.nextDrawDisabledStatus);
    }
    DeckDisplay.prototype.applyStatus = function() {
        if (!isDrawing) this.applyNextDrawDisabledStatus();
        document.getElementById(this.shuffleBtnId).disabled = !this.deck.shouldShuffle;
        document.getElementById(this.unlockBtnId).disabled = !this.deck.isLocked;
        let responseText = document.getElementById(this.responseStatusArea).innerHTML;
        if(responseText != undefined && responseText.includes("shuffling") && !this.deck.shouldShuffle)
            updateElement(this.responseStatusArea, false, "");
        if(responseText != undefined && responseText.includes("Lock") && !this.deck.isLocked)
            updateElement(this.responseStatusArea, false, "");
    }
    DeckDisplay.prototype.reportStatus = function() {
        let result = this.deck.remainingCardsCount + "/" + (this.deck.remainingCardsCount + this.deck.discardsCount);
        result += "&nbsp;(" + this.deck.discardsCount + ")";
        updateElement(this.statusId, false, result);
    }
    DeckDisplay.prototype.displayCardBack = function() {
        let card = new Card(this.deck, "back");
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(0, 0, true);
    }
    DeckDisplay.prototype.matches = function(path) {
        return this.deck.matches(path);
    }

    function CardDisplay(card) {
        this.card = card;
    }
    CardDisplay.prototype.display = function(teaseTimeMs, postDisplayWaitTimeMs, hasMoreDrawingToDo) {
        let cardUrl = this.card.url;
        let altText = this.card.action;
        let qm = quoteMarkFor(altText);
        let newHtml = "<img class='external_image large_card_image' src='" + cardUrl + "'" + " alt=" + qm + altText +
            qm + "/>";
        let startOfWait = (new Date()).getTime();
        preloadImage(cardUrl, async function() {
                let endOfWait = (new Date()).getTime();
                let timeToSleep = Math.max(0, teaseTimeMs - (endOfWait - startOfWait));
                await sleep(timeToSleep);
                updateElement("/nav/card", false, newHtml);
                await sleep(Math.max(0, postDisplayWaitTimeMs));
                finishRequest(hasMoreDrawingToDo);
            });
    }

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function quoteMarkFor(text) {
        let qm = '"';
        if (text.includes(qm)) qm = "'";
        return qm;
    }

    function sleep(timeToSleepMs) {
        return new Promise(resolve => setTimeout(resolve, timeToSleepMs));
    }

    function preloadImage(url, callback) {
        let img = new Image();
        img.src = url;
        img.onload = callback;
    }

    function startWithSlash(text) {
        if ((text) && (!text.startsWith("/"))) text = "/" + text;
        return text;
    }

    function getUrl(path) {
        path = startWithSlash(path);
        return "http://" + hostPort + path;
    }

    function updateElement(targetId, addEmphasis, newHtml) {
        if (addEmphasis) newHtml = "<font color='red'>" + newHtml + "</font>";
        document.getElementById(targetId).innerHTML = newHtml;
    }

    function createCookie(name, value, hours) {
        let expires = "";
        if (hours) {
            let date = new Date();
            date.setTime(date.getTime() + (hours * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }

    function getCookie(c_name) {
        if (document.cookie.length > 0) {
            let c_start = document.cookie.indexOf(c_name + "=");
            if (c_start != -1) {
                c_start = c_start + c_name.length + 1;
                let c_end = document.cookie.indexOf(";", c_start);
                if (c_end == -1) {
                    c_end = document.cookie.length;
                }
                return unescape(document.cookie.substring(c_start, c_end));
            }
        }
        return "";
    }

    function webSocketState(socketToCheck) {
        return socketToCheck==null?"undefined": socketToCheck.readyState;
    }

    async function setupStatus() {
        let socketToCheck = webSocket;

        if(socketToCheck) {
            console.log("entering setupStatus ws rs " + socketToCheck.readyState);
            }
        else console.log(" entering setupStatus, ws is undefined");

        if(isWebSocketOpen(socketToCheck) ) {
            console.log("setupStatus false alarm. returning");
            return;
        } else {
            console.log("after check setupStatus ws rs, status? "
            + (socketToCheck==null?"undefined": socketToCheck.readyState));
            if (socketToCheck != null) socketToCheck.close(3000, "not open");
            console.log("closed socket");
        }

        let newSocket = new WebSocket("ws://" + hostPort + "/status");
        webSocket=newSocket;

        webSocket.onmessage = function(msg) {
            console.log("websocket message from " + msg.origin + " " + webSocketState(this));
            DeckDisplay.updateStatus(msg);
        };
        webSocket.onclose = async function() {
            showOverlay("#balladOverlay");
         }
        webSocket.onopen = function(e) {
            console.log("WebSocket connection open. Asking for status update. " + this.readyState);
            window.location.href="#";
            this.send('update status');
             //TODO do something about repeating over all decks
            forEachDeckDisplay(function(value, key, map) {composeDescription(value);});

        };
        webSocket.onerror = function(e) {showOverlay("#balladOverlay");
            // console.log("Error in web socket. EOF?." + webSocketState(this)+ " top?" + (this==aSockets[aSockets.length - 1]));
            };
        return newSocket;
    }

    function tryStatusAgain() {
        setupStatus();
        if (isWebSocketOpen(webSocket)) {
            location.href="#";
            return;
        }
    }

    function isWebSocketOpen(socketToCheck) {
        let isWebSocketOpen = (socketToCheck != null) && socketToCheck.readyState == 1;
        return isWebSocketOpen;
    }

    function statusResetRequired(path) {
       if(isWebSocketOpen(webSocket)) return false;

       setupStatus();
       if(!isWebSocketOpen()) {
           showOverlay("#balladOverlay");
           return true;
       }

       return false;
      }

    function sendRequest(method, path, onLoadCallback, onErrorCallback) {
        if (statusResetRequired(path)) return;

        let xhttp = new XMLHttpRequest();
        xhttp.addEventListener("load", function(ev) { onLoadCallback(xhttp); });
        xhttp.addEventListener("error", function(ev) {  onErrorCallback(xhttp);   });
        xhttp.open(method, getUrl(path), true);
        //	  xhttp.setRequestHeader("Authorize", "dm9yZGVsOnZvcmRlbA==");
        xhttp.send();
    }

    function get(path, onLoadCallback, onErrorCallback) {
        sendRequest("GET", path, onLoadCallback, onErrorCallback);
    }

    function post(path, onLoadCallback, onErrorCallback) {
        sendRequest("POST", path, onLoadCallback, onErrorCallback);
    }

    function del(path, onLoadCallback, onErrorCallback) {
        sendRequest("DELETE", path, onLoadCallback, onErrorCallback);
    }

    function processActionResponse(xhttp, deckDisplay, successCallback) {
        let requestStatusCode = xhttp.status;

        switch (requestStatusCode) {
            case 200:
                successCallback(deckDisplay, xhttp.responseText)
                updateRequestId(xhttp.getResponseHeader("id"));
                return;
            case 404:
                deckDisplay.reportError("Needs shuffling!");
                break;
            case 409:
                deckDisplay.reportError("Locked!");
            default:
                deckDisplay.reportUnexpectedError(xhttp);
        }
        finishRequest(false);
    }

    function finishRequest(hasMoreDrawingToDo) {
        if(isDrawing) isDrawing=hasMoreDrawingToDo;
        applyStatusForAllDecks();
    }

    function updateRequestId(id) {
        let target = "requestId";
        updateElement(target, false, id);
    }

    function setHistory(history) {
        updateElement("history", false, history);
        createCookie("moveHistory", history, 12);
    }

    function getTimestamp() {
        return new Date().toLocaleTimeString('en-US', {hour12: false });
    }
    function updateHistory(card) {
        let anchorText = getTimestamp();
        let sector = card.deck.navPath.replace("/", "");
        sector = sector.replace("/nav", "");
        sector = capitalizeFirstLetter(sector);
        anchorText += " " + sector + "-" + card.action;
        let item = card.getAnchor(anchorText);
        let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
        setHistory(history);
    }

    function forEachDeckDisplay(valueKeyMap) {
        dds.forEach(valueKeyMap);
    }

    function disableDrawButtons() {
        forEachDeckDisplay(function(value, key, map) {
            value.disableDrawCardButton(true);
        });
    }

    function applyStatusForAllDecks() {
        forEachDeckDisplay(function(value, key, map) {
            value.applyStatus();
        });
    }

    function displayNavCard(deckDisplay, responseText) {
        let card = Card.FromJson(deckDisplay.deck, responseText);
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(500, 500, false);
        deckDisplay.updateResponse("&nbsp;");
        updateHistory(card);
    }

    function justDisplayResponse(deckDisplay, responseText) {
        forEachDeckDisplay(function(value, key, map) {value.updateResponse("&nbsp;");});
        deckDisplay.updateResponse(responseText);
    }

    function displayResponseInOverlay(deckDisplay, responseText) {
        let html = "<table class='border-on-bottom'>";
        let cards = JSON.parse(responseText);
        for (let i = 0; i < cards.length; ++i) {
            let cardCount = cards[i];
            let card = new Card(deckDisplay.deck, cardCount.key);
            html += "<tr><td class='align_right'>" + card.getAnchor(card.action) +
                "</td><td class='align_right px80wide'>" + cardCount.value + "&nbsp;</td></tr>";
        }
        html += "</table>";
        updateElement(deckDisplay.specAreaId, false, html);
    }

    function createOnSendErrorCallback(deckDisplay) {
        return function(xhttp) {
            deckDisplay.reportUnexpectedError("Send failed.");
            finishRequest();
        };
    }

    function createOnSendLoadCallback(deck, successCallback) {
            return function(xhttp) {
                return processActionResponse(xhttp, deck, successCallback);
            };
        }

        //TODO put drawCard et. al on DeckDisplay when i figure out private functions (which most of these shoudl be)
        //     or is this now modules?
    function drawCard(deckDisplay) {
        recordFlyAction();
        if (!continueIfMoreThan2Actions(document.getElementById("flyCb"))) return;

        let deck = deckDisplay.deck;
        isDrawing = true;
        disableDrawButtons();
        deckDisplay.displayCardBack();
        get(deck.navPath, createOnSendLoadCallback(deckDisplay, displayNavCard), createOnSendErrorCallback(
            deckDisplay));
    }

    function lock(deckDisplay) {
        post(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function unlock(deckDisplay) {
        del(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function shuffle(deckDisplay) {
        if (confirm("Are you sure?")) shuffleDontAsk(deckDisplay);
    }

    function shuffleDontAsk(deckDisplay) {
        post(deckDisplay.deck.navPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
        createOnSendErrorCallback(deckDisplay));
    }

    function resetAll() {
        if (confirm("Are you *really* sure?"))
            forEachDeckDisplay(function(value, key, map) {  shuffleDontAsk(value);  });
    }

    function describe(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function showWebsocketState() {
        console.log("ws " + webSocket.readyState);
    }

    function clearHistory() {
       // webSocket.close();
        setHistory("");
    }

    function countCheckboxes() {
        let counter = 0;
        for(let i = 0; i < actionCheckboxes.length; ++i) {
            let checkbox=document.getElementById(actionCheckboxes[i]);
            if (checkbox.checked) counter++;
        }
        return counter;
    }

    function startTurn() {
        let checks = countCheckboxes();
        if (checks < 2 && (!confirm("Fewer than 2 actions. Are you sure?"))) return;

        //TODO use closure to dry looping over checkboxes.
        for(let i = 0; i < actionCheckboxes.length; ++i)
            document.getElementById(actionCheckboxes[i]).checked = false;

        let item="<p>" + getTimestamp() + " Start Turn</p>" + "<hr class='half-line'>";
        let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
        setHistory(history);
        updateElement("/nav/card", false,
            "<img src='/SerenityLogo.png' class='external_image logo_image'>");
    }

    function recordFlyAction() {
        document.getElementById("flyCb").disabled=false;
        document.getElementById("flyCb").checked=true;
        document.getElementById("flyCb").disabled=true;
    }

    function continueIfMoreThan2Actions(checkbox) {
        let checks = countCheckboxes();
        if (checks > 2 && (!confirm("More than 2 actions. Are you sure?"))) {
            checkbox.checked = false;
            return false;
        }
        return true;
    }

    function recordAction(checkbox) {
        if (!checkbox.checked) {
            let item="<p>" + getTimestamp() + " Un-" + checkbox.name +"</p>";
            let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
            setHistory(history);
            return;
        }

        if (!continueIfMoreThan2Actions(checkbox)) return;

        let item="<p>" + getTimestamp() + " " + checkbox.name +"</p>";
        let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
        setHistory(history);
    }

    function composeDescription(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function debounce(fun, milliSeconds) {
        var timer;
        return function() {
            clearTimeout(timer);
            timer = setTimeout(function() {
                fun();
            }, milliSeconds);
        };
    }

    function showOverlay(hrefToShow) {
        if (location.hash == hrefToShow) return;
        debounce(function() {
            document.querySelector('body').classList.add('noscroll');
            document.querySelector('html').classList.add('noscroll');
            location.href = hrefToShow;
        }, 200).call();
    }

    function restoreScrolling() {
                document.querySelector('body').classList.remove('noscroll');
                document.querySelector('html').classList.remove('noscroll');
    }

    function restoreScrollingAfterClosingOverlays() {
         let anchors = document.getElementsByClassName("close");
         for(let i = 0; i < anchors.length; i++) {
            let anchor = anchors[i];
            anchor.addEventListener("click",restoreScrolling(),false);
         }

         window.addEventListener('popstate', function(event) {
          let fragment = document.location.hash;
          if (""==fragment) restoreScrolling();
        }, true);

    }

    window.onerror = function (msg, url, lineNo, columnNo, error) {
        var string = msg.toLowerCase();
        var substring = "script error";
        if (string.indexOf(substring) > -1){
            alert('Script Error: See Browser Console for Detail');
        } else {
            var message = [
                'Message: ' + msg,
                'URL: ' + url,
                'Line: ' + lineNo,
                'Column: ' + columnNo,
                'Error object: ' + JSON.stringify(error)
            ].join(' - ');

            alert(message);
        }

        return false;
    };

    window.onload = async function(e) {
        let history = getCookie("moveHistory");
        updateElement("history", false, history);
        restoreScrollingAfterClosingOverlays();
      //  alert("user agent " +  navigator.userAgent);
     };

    </script>
</head>

<body style="width=100%;">
<section>
    <!--TODO use the fieldset to get the checkboxes, not the array-->
    <fieldset>
        <table style="width:909px;border-collapse: collapse;">
            <tr>
                <td style="width:150px;">
                <button id="turnBtn" class="button_with_text" type="button" onclick="startTurn()">Next Turn
                </button>
            </td>


                <td>
                    <input type="checkbox" name="Work" id="workCb" class="large" onclick="recordAction(this)"/>
                    <label for="workCb" class="chkbox">&nbsp;Work</label></td>
                <td>
                    <input type="checkbox" name="Deal" id="dealCb" class="large" onclick="recordAction(this)"/>
                    <label for="dealCb" class="chkbox">&nbsp;&nbsp;Deal</label></td>
                <td>
                    <input type="checkbox" name="Buy" id="buyCb" class="large" onclick="recordAction(this)"/>
                    <label for="buyCb" class="chkbox">&nbsp;&nbsp;&nbsp;Buy</label></td>
                <td>
                    <input type="checkbox" name="Fly" id="flyCb" class="large" disabled/>
                    <label for="flyCb" class="chkbox disabled">&nbsp;&nbsp;&nbsp;Fly</label></td>

            </tr>
        </table>
    </fieldset>

</section>
<hr size="2">
<section style="width: 100%;">
<table id="deckTable">
    <tr>
        <td id="/nav/card" colspan="3"><img src="/SerenityLogo.png" class='external_image logo_image'>
        </td>
    </tr>
    <tr id="drawActions">
        <td>
            <div id="/alliance/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_al)"></div>
        </td>
        <td>
            <div id="/border/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_bo)"></div>
        </td>
        <td>
            <div id="/rim/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_ri)"></div>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/status"></span></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/requestResult">&nbsp;</span>
            </p>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_al)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_bo)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_ri)">Lock Deck
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_al)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_bo)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/unlockBtn" class="button_with_text top_margin" type="button" onclick="unlock(dd_ri)">
                Unlock Deck
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/shuffleBtn" class="button_with_text top_margin " type="button"
                    onclick="shuffle(dd_al)">Shuffle
            </button>
        </td>
        <td>
            <button id="/border/nav/shuffleBtn" class="button_with_text top_margin" type="button"
                    onclick="shuffle(dd_bo)">Shuffle
            </button>
        </td>
        <td>
            <button id="/rim/nav/shuffleBtn" class="button_with_text top_margin" type="button" onclick="shuffle(dd_ri)">
                Shuffle
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/alliance/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/border/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/rim/nav/specOverlay');">Deck
            </button>
        </td>
    </tr>

</table>
</section>

<br>

<hr size="2">

<button id="resetAllBtn" class="button_with_text top_margin" type="button" onclick="resetAll()">Shuffle All
</button>
<br>
<button id="historyBtn" class="button_with_text top_margin" type="button" onclick="clearHistory()">Clear History
</button>
<h1>History</h1>
<ol start="0" class="less_on_top"><span id="history"></span>
</ol>
    <p>Request id: <span id="requestId"></span></p>
</section>


<section>
    <div id="/alliance/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/alliance/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="/border/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/border/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="/rim/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/rim/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="balladOverlay" class="overlay to-the-black">
        <div id="balladPopup" class="popup to-the-black">
            <h1 class="to-the-black"><a href="https://www.youtube.com/watch?v=7DiWxcilWtU" target="_blank">Ballad of
                Serenity</a><br>&emsp;by Sonny Rhodes</h1>
            <a class="close to-the-black" onclick="tryStatusAgain()">&#10006;</a>
            <div id="balladOverlayDiv" class="content to-the-black">

                Take my love.<br>
                Take my land.<br>
                Take me where I cannot stand.<br>
                I don't care,<br>
                I'm still free.<br>
                You can't take the sky from me.<br>
                <br>
                Take me out to the black.<br>
                Tell em I ain't comin' back.<br>
                Burn the land<br>
                And boil the sea.<br>
                You can't take the sky from me.<br>
                <br>
                There's no place I can't be<br>
                Since I found Serenity.<br>
                <a href="https://www.youtube.com/watch?v=opZIBaBjN08" target="_blank">But you can't take the sky from
                    me.</a><br>

            </div>
        </div>
    </div>
</section>
</body>

</html>
