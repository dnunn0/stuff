<!DOCTYPE html>
<html>
<head>
    <style>
        .external {
           -moz-force-broken-image-icon: 1;
           height: 1040px;width: 715px;
                    }
         .button_image {
           -moz-force-broken-image-icon: 1;
            height: 100%;
            width: 75%;
            }
        .button_with_image {
            padding: 0;
            border: none;
            background: none;
         }
         .button_with_text_no_top_margin {
            font-size: 2.5rem;
         }
         .button_with_text {
            margin: 2.5rem 0rem 0rem 0rem;
            font-size: 2.5rem;
         }
         p {font-size: 3rem;}
         a {font-size: 3rem;}
         ol {font-size: 3rem;margin-bottom: 0.5rem;}
         td {text-align: center;}
         table {width:100%;margin: 2.5rem 0% 0% 0%;}
         .less_on_top {margin-top: -10px;}
    </style>
    <title>Firefly</title>
    <script>
        let navLockPath = "/lock";
        let hostPort = location.hostname + ":" + location.port;
        let isDrawing=false;
        let decks = ["/alliance/nav", "/border/nav", "/rim/nav"];
        let nextDrawDisabledStatus= new Map();
        for(let i = 0, len = decks.length; i< len; ++i) {
            nextDrawDisabledStatus.set(decks[i], false);
        }
        setupStatus();

    function setupStatus() {
        let statusUrl="ws://" + hostPort + "/status";
        let webSocket = new WebSocket(statusUrl);
        webSocket.onmessage = function (msg) { updateStatus(msg); };
        webSocket.onclose = function () { console.log("WebSocket connection closed ") }
        webSocket.onopen = function(e) {
            console.log("WebSocket connection open. Asking for status update. ");
            webSocket.send('update status');
        };
    }

	function sendRequest(method, deck, path, callbackProcess, successCallback) {
	  let  xhttp = new XMLHttpRequest();
	  xhttp.addEventListener("load", function(ev){callbackProcess(xhttp, deck, successCallback); });
	  xhttp.addEventListener("error", function(ev){updateElement(deck +"/"+"requestResult", true, "Request probably didn't get to server.");});

	  xhttp.open(method, getUrl(deck, path), true);
//	  xhttp.setRequestHeader("Authorize", "dm9yZGVsOnZvcmRlbA==");
	  xhttp.send();
	}

    function startWithSlash(text) {
      if ((text) && (!text.startsWith("/"))) text ="/"+text;
      return text;
    }

	function getUrl(deck, path) {
	    path = startWithSlash(path);
	    return "http://"+hostPort+ deck + path;
	}

	function getCardUrl(deck, cardName) {
	    cardName = startWithSlash(cardName);
	    return "http://"+hostPort+ deck + "Card" + cardName;
	}

	function updateElement(target, addEmphasis, newHtml) {
	  if (addEmphasis) newHtml = "<font color='red'>" + newHtml + "</font>";
	  document.getElementById(target).innerHTML = newHtml;
	}

	function processActionResponse(xhttp, deck, cardArea, responseStatusArea, successCallback) {
		switch (xhttp.status) {
		  case 200:
			successCallback(xhttp, deck, cardArea, responseStatusArea)
			break;
		  case 404:
			updateElement(deck +"/"+responseStatusArea, true, "Needs shuffling!");
			break;
		  case 409:
			updateElement(deck +"/"+responseStatusArea, true, "Locked!");
			break;
		  default:
			displayUnexpectedError(xhttp, deck, responseStatusArea);
		}
	}

	function displayUnexpectedError(xhttp, deck, target) {
		let  result = "Unexpected error: ReadyState, status, text: " + xhttp.readyState + "- " + xhttp.status + "-" + xhttp.statusText + ".";
	    updateElement(deck +"/"+target, true, result);
	}

	function updateRequestId(id, deck, shouldOverride) {
		let  target = "requestId";
		if (shouldOverride || "" == document.getElementById(target).innerHTML)
			updateElement(target, false, id);
	}

	function justDisplayResponse(xhttp, deck, cardArea, responseStatusArea) {
	  let  result = xhttp.responseText;
	  let  target = responseStatusArea;
	  updateResponse(result, deck, responseStatusArea);
	  updateRequestId(xhttp.getResponseHeader("id"), deck, true);
	}

    function updateResponse(response, deck, responseStatusArea) {
	  let  target = responseStatusArea;
	  updateElement(deck +"/"+target, false, response);
	}

	function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

	function updateHistory(deck, card) {
	    let  anchorText = deck.replace("/","");
	    anchorText = anchorText.replace("/nav", "");
	    anchorText = capitalizeFirstLetter(anchorText);
	    anchorText += "-"+card.action;
		let  item = "<a href='"+getCardUrl(deck, cardPicName(card.action))+"' target='_blank'>"+ anchorText + "</a>";
		updateElement("history", false, "<li>"+item+"</li>" + document.getElementById("history").innerHTML);
	}

	function quoteMarkFor(text) {
	    let  qm = '"';
	    if (text.includes(qm)) qm = "'";
	    return qm;
	 }

    function sleep(timeToSleepMs) {
       return new Promise(resolve => setTimeout(resolve, timeToSleepMs));
   }

	function preloadImage(url, callback)
    {
        let  img=new Image();
        img.src=url;
        img.onload = callback;
    }

    function disableDrawButtons() {
        for(let i=0, len=decks.length; i < len; i++) {
            let control = document.getElementById(decks[i]+"/drawBtn");
            control.disabled = true;
        }
    }

    function restoreDrawButtons() {
        for(let i=0, len=decks.length; i < len; i++) {
            let control = document.getElementById(decks[i]+"/drawBtn");
            control.disabled = nextDrawDisabledStatus.get(decks[i]);
        }
    }

	function displayNavCard(xhttp, deck, cardArea, responseStatusArea) {
	  let  target = cardArea;
	  let  card = JSON.parse(xhttp.responseText);
	  let  cardUrl = getCardUrl(deck, cardPicName(card.action));
      let  qm = quoteMarkFor(card.action);
      let  newHtml = "<img class='external' src='" + cardUrl +"'"
                + " alt="+qm+card.action+qm
                +"/>";
      let  startOfWait = (new Date()).getTime();
	  preloadImage(cardUrl, async function() {
	      let  teaseTime = 750;
	      let  endOfWait = (new Date()).getTime();
	      let  timeToSleep = Math.max(1, teaseTime - (endOfWait - startOfWait));
          await sleep(timeToSleep);

          updateElement("/nav/card", false, newHtml);
          await sleep(1200);
          restoreDrawButtons();
          isDrawing=false;
      });
      updateResponse("&nbsp;", deck, responseStatusArea);
	  updateRequestId(xhttp.getResponseHeader("id"), deck, true);
	  updateHistory(deck, card);
	}

	function cardPicName(cardName) {
		return cardName.replace(/[^a-zA-Z]/g, "")+".png";
	}

	function processActionResponseFun(xhttp, deck, successCallback) {
	  return processActionResponse(xhttp, deck, "card", "requestResult", successCallback);
	}

	function get(deck, path) {
	   isDrawing=true;
       disableDrawButtons();
	  let  newHtml = "<img class='external' src='" + getCardUrl(deck, cardPicName("back")) +"'"
				+ " alt='"+(deck.replace(/[^a-zA-Z]/g, " "))+"'"
				+"/>";
	  updateElement("/nav/card", false, newHtml);
	  sendRequest("GET", deck, path, processActionResponseFun, displayNavCard);
	}

	function post(deck, path) {
	  sendRequest("POST", deck, path, processActionResponseFun, justDisplayResponse);
	}

	function del(deck, path) {
	  sendRequest("DELETE", deck, path, processActionResponseFun, justDisplayResponse);
	}

	function clearHistory() {
		updateElement("history", false, "");
	}

    function getPageUrl() {
        return document.location.toString();
    }

    function updateStatus(msg) {
	  let  stat = JSON.parse(msg.data);
	  let  deck = stat.source;
	  let  result = stat.remainingCardsCount +"/" + (stat.remainingCardsCount+stat.discardsCount);
	  result += "&nbsp;(" + stat.discardsCount +")";
	  updateElement(deck +"/status", false, result);

	  let  hasCards = stat.remainingCardsCount > 0;
	  let  isLocked = stat.isLocked;
	  nextDrawDisabledStatus.set(deck, !hasCards || isLocked);
	  if(!isDrawing) {
	      document.getElementById(deck + "/drawBtn").disabled = nextDrawDisabledStatus.get(deck);
	  }
	  document.getElementById(deck + "/shuffleBtn").disabled = hasCards || isLocked;
	  document.getElementById(deck + "/unlockBtn").disabled = !isLocked;
    }


	window.onload = function(e) {
	};

	;

    </script>
</head>

<body>
<table>
    <tr>
        <td><span id="/nav/card"><img src="/alliance/navCard/back.png" class='external'></span><br></td>
    </tr>
</table>

<table>
    <tr id="drawActions">
        <td>
            <button class="button_with_image" id="/alliance/nav/drawBtn" type="button"
                    onclick="get('/alliance/nav', '')">
                <img src="/alliance/navCard/back.png" -alt='Request Alliance Nav card' class="button_image"/>
            </button>
        </td>
        <td>
            <button class="button_with_image" id="/border/nav/drawBtn" type="button" onclick="get('/border/nav', '')">
                <img src="/border/navCard/back.png" -alt='Request Border Nav card' class="button_image"/>
            </button>
        </td>
        <td>
            <button class="button_with_image" id="/rim/nav/drawBtn" type="button" onclick="get('/rim/nav', '')">
                <img src="/rim/navCard/back.png" -alt='Request Rim Nav card' class="button_image"/>
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/status"></span></p>
        </td>
    </tr>
    <tr>
        <td>
            <p><span id="/alliance/nav/requestResult">&nbsp;</span></p>
        </td>
        <td>
            <p><span id="/border/nav/requestResult">&nbsp;</span></p>
        </td>
        <td>
            <p><span id="/rim/nav/requestResult">&nbsp;</span></p>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="post('/alliance/nav', navLockPath)">Lock Deck
            </button>
            <button id="/alliance/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="del('/alliance/nav', navLockPath)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="post('/border/nav', navLockPath)">Lock Deck
            </button>
            <button id="/border/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="del('/border/nav', navLockPath)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="post('/rim/nav', navLockPath)">Lock Deck
            </button>
            <button id="/rim/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="del('/rim/nav', navLockPath)">Unlock Deck
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/shuffleBtn" class="button_with_text" type="button"
                    onclick="post('/alliance/nav', '')">Shuffle
            </button>
        </td>
        <td>
            <button id="/border/nav/shuffleBtn" class="button_with_text" type="button"
                    onclick="post('/border/nav', '')">Shuffle
            </button>
        </td>
        <td>
            <button id="/rim/nav/shuffleBtn" class="button_with_text" type="button" onclick="post('/rim/nav', '')">
                Shuffle
            </button>
        </td>
    </tr>

</table>

<br>


<button id="historyBtn" class="button_with_text" type="button" onclick="clearHistory()">Clear History</button>
<p>History
<ol class="less_on_top"><span id="history"></span></ol>
</p>
<p>Request id: <span id="requestId"/><br></p>


</body>
</html>

