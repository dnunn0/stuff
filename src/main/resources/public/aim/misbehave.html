<!DOCTYPE html>
<html>

<head>
    <style>
    html, body {
        height: 100%;
    }
    .noscroll { overflow: hidden; }

    h1 {
        font-size: 3.5rem;
    }
    p {
        font-size: 3rem;
    }
    a {
        font-size: 3rem;
    }
    ol {
        font-size: 3rem;
        margin-bottom: 0.5rem;
        margin-left: 3.5rem;
    }
    td {
        text-align: center;
    }
    img {
        padding: 0;
        margin: 0;
        border: 0;
    }
    td {
        text-align: center;
    }
    #deckTable {
        table-layout: fixed;
    }
    button {
        font-size: 3rem;
        border: none;
    }
    .less_on_top {
        margin-top: -10px;
    }
    .external_image {
        -moz-force-broken-image-icon: 1;
    }
    .logo_image {
        height: 800px;
    }
    .large_card_image {
        height: 800px;
    }
    .mediumCard {
        height: 384px;
        width: 264px;
        margin: 0 10px 0 30px;
        background-repeat: no-repeat;
        background-size: contain;
        cursor: pointer;
        transition: all 0.3s ease-out;
    }
    #\/alliance\/nav\/drawBtn {
        background-image: url(/alliance/navCard/back.png);
    }
    #\/border\/nav\/drawBtn {
        background-image: url(/border/navCard/back.png);
    }
    #\/rim\/nav\/drawBtn {
        background-image: url(/rim/navCard/back.png);
    }

    .top_margin {
        margin: 50px 0 0 0;
    }
    .button_with_text {
        border: 2px solid #06D85F;
        border-radius: 20px/50px;
        cursor: pointer;
        transition: all 0.3s ease-out;
    }
    .button_with_text:disabled {
        border: 2px solid transparent;
    }
    .overlay {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.7);
        transition: opacity 500ms;
        visibility: hidden;
        opacity: 0;
    }
    .overlay:target {
        visibility: visible;
        opacity: 1;
    }
    .popup {
        overflow-y: auto;
        margin: 70px auto;
        padding: 0;
        background: #fff;
        border-radius: 5px;
        width: 80%;
        position: relative;
        transition: all 5s ease-in-out;
    }
    .popup .close {
        padding: 0;
        margin: 0;
        position: absolute;
        top: 00px;
        right: 15px;
        transition: all 200ms;
        font-size: 50px;
        font-weight: bold;
        text-decoration: none;
        color: #333;
    }
    .popup .close:hover {
        color: #06D85F;
    }
    .popup .content {
        max-height: 100%;
        overflow: auto;
    }
    .popup table {
        font-size: 3rem;
        width: 100%;
        margin: 0% 0px 7px 0%;
        border-collapse: collapse;
        border-bottom: 5px solid black;
    }
    .popup tr:nth-child(even) {
        background-color: whitesmoke;
    }
    .popup h1 {
        margin: 0% 0% 0% 0%;
    }
    .align_right {
        text-align: right;
    }
    .disabled {
        opacity: 0.3;
        pointer-events: none;
    }

    </style>
    <title>Firefly</title>
    <script>
    let hostPort = location.hostname + ":" + location.port;
    let isDrawing = false;
    //TODO at some point, figure out how to restore closed websocket
    let statusUrl = "ws://" + hostPort + "/status";
    let webSocket = new WebSocket(statusUrl);
    setupStatus(webSocket);
    let deck_al = new Deck("/alliance/nav");
    let deck_bo = new Deck("/border/nav");
    let deck_ri = new Deck("/rim/nav");
    let decks = new Map();
    decks.set(deck_al.navPath, deck_al);
    decks.set(deck_bo.navPath, deck_bo);
    decks.set(deck_ri.navPath, deck_ri);
    let dd_al = new DeckDisplay(deck_al);
    let dd_bo = new DeckDisplay(deck_bo);
    let dd_ri = new DeckDisplay(deck_ri);
    let dds = new Map();
    dds.set(deck_al, dd_al);
    dds.set(deck_bo, dd_bo);
    dds.set(deck_ri, dd_ri);

    function Deck(navPath) {
        this.navPath = navPath;
        this.navLockPath = navPath + "/lock";
        this.specPath = navPath + "/spec";
        this.remainingCardsCount = -1;
        this.discardsCount = -1;
        this.isLocked = false;
        this.hasCards = false;
        this.nextDrawDisabledStatus = false;
        this.shouldShuffle = false;
    }
    Deck.FindAndUpdateFrom = function(statusJsonString) {
        let statusj = JSON.parse(statusJsonString);
        let deckName = statusj.source;
        let deck = decks.get(deckName);
        deck.remainingCardsCount = statusj.remainingCardsCount;
        deck.discardsCount = statusj.discardsCount;
        deck.isLocked = statusj.isLocked;
        deck.hasCards = deck.remainingCardsCount > 0;
        deck.nextDrawDisabledStatus = !deck.hasCards || deck.isLocked;
        deck.shouldShuffle = !(deck.hasCards || deck.isLocked);
        return deck;
    }

    function Card(deck, action) {
        this.deck = deck;
        this.action = action;
        let cardName = this.action.replace(/[^a-zA-Z]/g, "") + ".png";
        cardName = startWithSlash(cardName);
        this.url = "http://" + hostPort + this.deck.navPath + "Card" + cardName;
    }
    Card.FromJson = function(deck, cardJsonString) {
        let cardj = JSON.parse(cardJsonString);
        return new Card(deck, cardj.action);
    }
    Card.prototype.getAnchor = function(anchorText) {
        return "<a href='" + this.url + "' target='_blank'>" + anchorText + "</a>";
    }

    function DeckDisplay(deck) {
        this.deck = deck;
        this.responseStatusArea = deck.navPath + "/requestResult";
        this.drawBtnId = this.deck.navPath + "/drawBtn";
        this.shuffleBtnId = this.deck.navPath + "/shuffleBtn";
        this.unlockBtnId = this.deck.navPath + "/unlockBtn";
        this.statusId = this.deck.navPath + "/status";
        this.specAreaId = this.deck.navPath + "/spec";
    }
    DeckDisplay.updateStatus = function(msg) {
        let deck = Deck.FindAndUpdateFrom(msg.data);
        let displayDeck = dds.get(deck);
        displayDeck.reportStatus();
        displayDeck.applyStatus();
    }
    DeckDisplay.prototype.reportError = function(message) {
        updateElement(this.responseStatusArea, true, message);
    }
    DeckDisplay.prototype.reportUnexpectedError = function(xhttp) {
        let result = "Unexpected error: ReadyState, status, text: " + xhttp.readyState + "- " + xhttp.status + "-" +
            xhttp.statusText + ".";
        this.reportError(result);
    }
    DeckDisplay.prototype.updateResponse = function(message) {
        updateElement(this.responseStatusArea, false, message);
    }
    DeckDisplay.prototype.disableDrawCardButton = function(newState) {
        let control = document.getElementById(this.drawBtnId);
        if (newState) control.classList.add('disabled');
        else control.classList.remove('disabled');
    }
    DeckDisplay.prototype.applyNextDrawDisabledStatus = function() {
        //TODO how to make private methods (and then can make disable(id) private too)
        this.disableDrawCardButton(this.deck.nextDrawDisabledStatus);
    }
    DeckDisplay.prototype.applyStatus = function() {
        if (!isDrawing) this.applyNextDrawDisabledStatus();
        document.getElementById(this.shuffleBtnId).disabled = !this.deck.shouldShuffle;
        document.getElementById(this.unlockBtnId).disabled = !this.deck.isLocked;
    }
    DeckDisplay.prototype.reportStatus = function() {
        let result = this.deck.remainingCardsCount + "/" + (this.deck.remainingCardsCount + this.deck.discardsCount);
        result += "&nbsp;(" + this.deck.discardsCount + ")";
        updateElement(this.statusId, false, result);
    }
    DeckDisplay.prototype.displayCardBack = function() {
        let card = new Card(this.deck, "back");
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(0, 0, true);
    }

    function CardDisplay(card) {
        this.card = card;
    }
    CardDisplay.prototype.display = function(teaseTimeMs, postDisplayWaitTimeMs, hasMoreDrawingToDo) {
        let cardUrl = this.card.url;
        let altText = this.card.action;
        let qm = quoteMarkFor(altText);
        let newHtml = "<img class='external_image large_card_image' src='" + cardUrl + "'" + " alt=" + qm + altText +
            qm + "/>";
        let startOfWait = (new Date()).getTime();
        preloadImage(cardUrl, async function() {
                let endOfWait = (new Date()).getTime();
                let timeToSleep = Math.max(0, teaseTimeMs - (endOfWait - startOfWait));
                await sleep(timeToSleep);
                updateElement("/nav/card", false, newHtml);
                await sleep(Math.max(0, postDisplayWaitTimeMs));
                isDrawing = hasMoreDrawingToDo;
                applyStatusForAllDecks();
            });
    }

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function quoteMarkFor(text) {
        let qm = '"';
        if (text.includes(qm)) qm = "'";
        return qm;
    }

    function sleep(timeToSleepMs) {
        return new Promise(resolve => setTimeout(resolve, timeToSleepMs));
    }

    function preloadImage(url, callback) {
        let img = new Image();
        img.src = url;
        img.onload = callback;
    }

    function startWithSlash(text) {
        if ((text) && (!text.startsWith("/"))) text = "/" + text;
        return text;
    }

    function getUrl(path) {
        path = startWithSlash(path);
        return "http://" + hostPort + path;
    }

    function updateElement(targetId, addEmphasis, newHtml) {
        if (addEmphasis) newHtml = "<font color='red'>" + newHtml + "</font>";
        document.getElementById(targetId).innerHTML = newHtml;
    }

    function createCookie(name, value, hours) {
        let expires = "";
        if (hours) {
            let date = new Date();
            date.setTime(date.getTime() + (hours * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }

    function getCookie(c_name) {
        if (document.cookie.length > 0) {
            let c_start = document.cookie.indexOf(c_name + "=");
            if (c_start != -1) {
                c_start = c_start + c_name.length + 1;
                let c_end = document.cookie.indexOf(";", c_start);
                if (c_end == -1) {
                    c_end = document.cookie.length;
                }
                return unescape(document.cookie.substring(c_start, c_end));
            }
        }
        return "";
    }

    function setupStatus(webSocket) {
        webSocket.onmessage = function(msg) {
            DeckDisplay.updateStatus(msg);
        };
        webSocket.onclose = function() {
            console.log("WebSocket connection closed ")
        }
        webSocket.onopen = function(e) {
            console.log("WebSocket connection open. Asking for status update. ");
            webSocket.send('update status');
        };
    }

    function sendRequest(method, path, onLoadCallback, onErrorCallback) {
        let xhttp = new XMLHttpRequest();
        xhttp.addEventListener("load", function(ev) {
            onLoadCallback(xhttp);
        });
        xhttp.addEventListener("error", function(ev) {
            onErrorCallback(xhttp);
        });
        xhttp.open(method, getUrl(path), true);
        //	  xhttp.setRequestHeader("Authorize", "dm9yZGVsOnZvcmRlbA==");
        xhttp.send();
    }

    function get(path, onLoadCallback, onErrorCallback) {
        sendRequest("GET", path, onLoadCallback, onErrorCallback);
    }

    function post(path, onLoadCallback, onErrorCallback) {
        sendRequest("POST", path, onLoadCallback, onErrorCallback);
    }

    function del(path, onLoadCallback, onErrorCallback) {
        sendRequest("DELETE", path, onLoadCallback, onErrorCallback);
    }

    function processActionResponse(xhttp, deckDisplay, successCallback) {
        switch (xhttp.status) {
            case 200:
                successCallback(deckDisplay, xhttp.responseText)
                updateRequestId(xhttp.getResponseHeader("id"));
                break;
            case 404:
                deckDisplay.reportError("Needs shuffling!");
                break;
            case 409:
                deckDisplay.reportError("Locked!");
                break;
            default:
                deckDisplay.reportUnexpectedError(xhttp);
        }
    }

    function updateRequestId(id) {
        let target = "requestId";
        updateElement(target, false, id);
    }

    function setHistory(history) {
        updateElement("history", false, history);
        createCookie("moveHistory", history, 12);
    }

    function updateHistory(card) {
        let anchorText = card.deck.navPath.replace("/", "");
        anchorText = anchorText.replace("/nav", "");
        anchorText = capitalizeFirstLetter(anchorText);
        anchorText += "-" + card.action;
        let item = card.getAnchor(anchorText);
        let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
        setHistory(history);
    }

    function forEachDeckDisplay(valueKeyMap) {
        dds.forEach(valueKeyMap);
    }

    function disableDrawButtons() {
        forEachDeckDisplay(function(value, key, map) {
            value.disableDrawCardButton(true);
        });
    }

    function applyStatusForAllDecks() {
        forEachDeckDisplay(function(value, key, map) {
            value.applyStatus();
        });
    }

    function displayNavCard(deckDisplay, responseText) {
        let card = Card.FromJson(deckDisplay.deck, responseText);
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(400, 700, false);
        deckDisplay.updateResponse("&nbsp;");
        updateHistory(card);
    }

    function justDisplayResponse(deckDisplay, responseText) {
        deckDisplay.updateResponse(responseText);
    }

    function displayResponseInOverlay(deckDisplay, responseText) {
        let html = "<table>";
        let cards = JSON.parse(responseText);
        for (let i = 0; i < cards.length; ++i) {
            let cardCount = cards[i];
            let card = new Card(deckDisplay.deck, cardCount.key);
            html += "<tr><td class='align_right'>" + card.getAnchor(card.action) +
                "</td><td class='align_right'>&ensp;" + cardCount.value + "&emsp;</td></tr>";
        }
        html += "</table>";
        updateElement(deckDisplay.specAreaId, false, html);
    }

    function createOnSendErrorCallback(deckDisplay) {
        return function(xhttp) {
            deckDisplay.reportUnexpectedError("Send failed.");
        };
    }

    function createOnSendLoadCallback(deck, successCallback) {
            return function(xhttp) {
                return processActionResponse(xhttp, deck, successCallback);
            };
        }
        //TODO put drawCard et. al on DeckDisplay when i figure out private functions (which most of these shoudl be)
        //     or is this now modules?
    function drawCard(deckDisplay) {
            let deck = deckDisplay.deck;
            isDrawing = true;
            disableDrawButtons();
            deckDisplay.displayCardBack();
            get(deck.navPath, createOnSendLoadCallback(deckDisplay, displayNavCard), createOnSendErrorCallback(
                deckDisplay));
        }
        //TODO move lock, etc. into DeckDisplay? (Deck?--lots is UI related...)
    function lock(deckDisplay) {
        post(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function unlock(deckDisplay) {
        del(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function shuffle(deckDisplay) {
        if (confirm("Are you sure?") == true)
            post(deckDisplay.deck.navPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
                createOnSendErrorCallback(deckDisplay));
    }

    function describe(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function clearHistory() {
        setHistory("");
    }

    function composeDescription(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function debounce(fun, mil) {
        var timer;
        return function() {
            clearTimeout(timer);
            timer = setTimeout(function() {
                fun();
            }, mil);
        };
    }

    function show(hrefToShow) {
        debounce(function() {
          //  body.classList.toggle('noscroll');
            location.href = hrefToShow;
        }, 200).call();
    }
    window.onload = function(e) {
        let history = getCookie("moveHistory");
        updateElement("history", false, history);
        //TODO do something about repeating over all decks
        forEachDeckDisplay(function(value, key, map) {
            composeDescription(value);
        });
    };

    </script>
</head>

<body>
<div>

<table id="deckTable">
    <tr>
        <td id="/nav/card" colspan="3"><img src="/SerenityLogo.png" class='external_image logo_image'>
        </td>
    </tr>
    <tr id="drawActions">
        <td>
            <div id="/alliance/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_al)"/>
        </td>
        <td>
            <div id="/border/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_bo)"/>
        </td>
        <td>
            <div id="/rim/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_ri)"/>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/status"></span></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/requestResult">&nbsp;</span>
            </p>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_al)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_bo)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_ri)">Lock Deck
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_al)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_bo)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/unlockBtn" class="button_with_text top_margin" type="button" onclick="unlock(dd_ri)">
                Unlock Deck
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/shuffleBtn" class="button_with_text top_margin " type="button"
                    onclick="shuffle(dd_al)">Shuffle
            </button>
        </td>
        <td>
            <button id="/border/nav/shuffleBtn" class="button_with_text top_margin" type="button"
                    onclick="shuffle(dd_bo)">Shuffle
            </button>
        </td>
        <td>
            <button id="/rim/nav/shuffleBtn" class="button_with_text top_margin" type="button" onclick="shuffle(dd_ri)">
                Shuffle
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="show('#/alliance/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="show('#/border/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="show('#/rim/nav/specOverlay');">Deck
            </button>
        </td>
    </tr>

</table>

<br>

<button id="historyBtn" class="button_with_text top_margin" type="button" onclick="clearHistory()">Clear History
</button>
<h1>History</h1>
<ol start="0" class="less_on_top"><span id="history"></span>
</ol>
    <p>Request id: <span id="requestId"/></p>
</div>

<div id="/alliance/nav/specOverlay" class="overlay">
    <div class="popup">
        <h1>Cards</h1>
        <a class="close" href="#">&#10006;</a>
        <div id="/alliance/nav/spec" class="content"></div>
    </div>
</div>
<div id="/border/nav/specOverlay" class="overlay">
    <div class="popup">
        <h1>Cards</h1>
        <a class="close" href="#">&#10006;</a>
        <div id="/border/nav/spec" class="content"></div>
    </div>
</div>
<div id="/rim/nav/specOverlay" class="overlay">
    <div class="popup">
        <h1>Cards</h1>
        <a class="close" href="#">&#10006;</a>
        <div id="/rim/nav/spec" class="content"></div>
    </div>
</div>
</body>

</html>
