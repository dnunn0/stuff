<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" type="text/css" href="css.css" media="screen"/>
    <title>Firefly</title>
    <script>
    let hostPort = location.hostname + ":" + location.port;
    let isDrawing = false;
    let webSocket = null;
    setupStatus();
    let deck_al = new Deck("/alliance/nav");
    let deck_bo = new Deck("/border/nav");
    let deck_ri = new Deck("/rim/nav");
    let decks = new Map();
    decks.set(deck_al.navPath, deck_al);
    decks.set(deck_bo.navPath, deck_bo);
    decks.set(deck_ri.navPath, deck_ri);
    let dd_al = new DeckDisplay(deck_al);
    let dd_bo = new DeckDisplay(deck_bo);
    let dd_ri = new DeckDisplay(deck_ri);
    let dds = new Map();
    dds.set(deck_al, dd_al);
    dds.set(deck_bo, dd_bo);
    dds.set(deck_ri, dd_ri);

    function Deck(navPath) {
        this.navPath = navPath;
        this.navLockPath = navPath + "/lock";
        this.specPath = navPath + "/spec";
        this.remainingCardsCount = -1;
        this.discardsCount = -1;
        this.isLocked = false;
        this.hasCards = false;
        this.nextDrawDisabledStatus = false;
        this.shouldShuffle = false;
    }
    Deck.FindAndUpdateFrom = function(statusJsonString) {
        let statusj = JSON.parse(statusJsonString);
        let deckName = statusj.source;
        let deck = decks.get(deckName);
        deck.remainingCardsCount = statusj.remainingCardsCount;
        deck.discardsCount = statusj.discardsCount;
        deck.isLocked = statusj.isLocked;
        deck.hasCards = deck.remainingCardsCount > 0;
        deck.nextDrawDisabledStatus = !deck.hasCards || deck.isLocked;
        deck.shouldShuffle = !(deck.hasCards || deck.isLocked);
        return deck;
    }
    Deck.prototype.matches = function(path) {
        return (this.navPath==path) || (this.navLockPath==path) || (this.specPath==path);
    }


    function Card(deck, action) {
        this.deck = deck;
        this.action = action;
        let cardName = this.action.replace(/[^a-zA-Z]/g, "") + ".png";
        cardName = startWithSlash(cardName);
        this.url = "http://" + hostPort + this.deck.navPath + "Card" + cardName;
    }
    Card.FromJson = function(deck, cardJsonString) {
        let cardj = JSON.parse(cardJsonString);
        return new Card(deck, cardj.action);
    }
    Card.prototype.getAnchor = function(anchorText) {
        return "<a href='" + this.url + "' target='_blank'>" + anchorText + "</a>";
    }

    function DeckDisplay(deck) {
        this.deck = deck;
        this.responseStatusArea = deck.navPath + "/requestResult";
        this.drawBtnId = this.deck.navPath + "/drawBtn";
        this.shuffleBtnId = this.deck.navPath + "/shuffleBtn";
        this.unlockBtnId = this.deck.navPath + "/unlockBtn";
        this.statusId = this.deck.navPath + "/status";
        this.specAreaId = this.deck.navPath + "/spec";
    }
    DeckDisplay.updateStatus = function(msg) {
        let deck = Deck.FindAndUpdateFrom(msg.data);
        let displayDeck = dds.get(deck);
        displayDeck.reportStatus();
        displayDeck.applyStatus();
    }
    DeckDisplay.prototype.reportError = function(message) {
        updateElement(this.responseStatusArea, true, message);
    }
    DeckDisplay.prototype.reportUnexpectedError = function(xhttp) {
        let result = "Unexpected error: ReadyState, status, text: " + xhttp.readyState + "- " + xhttp.status + "-" +
            xhttp.statusText + ".";
        this.reportError(result);
    }
    DeckDisplay.prototype.updateResponse = function(message) {
        updateElement(this.responseStatusArea, false, message);
    }
    DeckDisplay.prototype.disableDrawCardButton = function(newState) {
        let control = document.getElementById(this.drawBtnId);
        if (newState) control.classList.add('disabled');
        else control.classList.remove('disabled');
    }
    DeckDisplay.prototype.applyNextDrawDisabledStatus = function() {
        //TODO how to make private methods (and then can make disable(id) private too)
        this.disableDrawCardButton(this.deck.nextDrawDisabledStatus);
    }
    DeckDisplay.prototype.applyStatus = function() {
        if (!isDrawing) this.applyNextDrawDisabledStatus();
        document.getElementById(this.shuffleBtnId).disabled = !this.deck.shouldShuffle;
        document.getElementById(this.unlockBtnId).disabled = !this.deck.isLocked;
        let responseText = document.getElementById(this.responseStatusArea).innerHTML;
        if(responseText != undefined && responseText.includes("shuffling") && !this.deck.shouldShuffle)
            updateElement(this.responseStatusArea, false, "");
        if(responseText != undefined && responseText.includes("Lock") && !this.deck.isLocked)
            updateElement(this.responseStatusArea, false, "");
    }
    DeckDisplay.prototype.reportStatus = function() {
        let result = this.deck.remainingCardsCount + "/" + (this.deck.remainingCardsCount + this.deck.discardsCount);
        result += "&nbsp;(" + this.deck.discardsCount + ")";
        updateElement(this.statusId, false, result);
    }
    DeckDisplay.prototype.displayCardBack = function() {
        let card = new Card(this.deck, "back");
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(0, 0, true);
    }
    DeckDisplay.prototype.matches = function(path) {
        return this.deck.matches(path);
    }

    function CardDisplay(card) {
        this.card = card;
    }
    CardDisplay.prototype.display = function(teaseTimeMs, postDisplayWaitTimeMs, hasMoreDrawingToDo) {
        let cardUrl = this.card.url;
        let altText = this.card.action;
        let qm = quoteMarkFor(altText);
        let newHtml = "<img class='external_image large_card_image' src='" + cardUrl + "'" + " alt=" + qm + altText +
            qm + "/>";
        let startOfWait = (new Date()).getTime();
        preloadImage(cardUrl, async function() {
                let endOfWait = (new Date()).getTime();
                let timeToSleep = Math.max(0, teaseTimeMs - (endOfWait - startOfWait));
                await sleep(timeToSleep);
                updateElement("/nav/card", false, newHtml);
                await sleep(Math.max(0, postDisplayWaitTimeMs));
                finishRequest(hasMoreDrawingToDo);
            });
    }

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function quoteMarkFor(text) {
        let qm = '"';
        if (text.includes(qm)) qm = "'";
        return qm;
    }

    function sleep(timeToSleepMs) {
        return new Promise(resolve => setTimeout(resolve, timeToSleepMs));
    }

    function preloadImage(url, callback) {
        let img = new Image();
        img.src = url;
        img.onload = callback;
    }

    function startWithSlash(text) {
        if ((text) && (!text.startsWith("/"))) text = "/" + text;
        return text;
    }

    function getUrl(path) {
        path = startWithSlash(path);
        return "http://" + hostPort + path;
    }

    function updateElement(targetId, addEmphasis, newHtml) {
        if (addEmphasis) newHtml = "<font color='red'>" + newHtml + "</font>";
        document.getElementById(targetId).innerHTML = newHtml;
    }

    function createCookie(name, value, hours) {
        let expires = "";
        if (hours) {
            let date = new Date();
            date.setTime(date.getTime() + (hours * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }

    function getCookie(c_name) {
        if (document.cookie.length > 0) {
            let c_start = document.cookie.indexOf(c_name + "=");
            if (c_start != -1) {
                c_start = c_start + c_name.length + 1;
                let c_end = document.cookie.indexOf(";", c_start);
                if (c_end == -1) {
                    c_end = document.cookie.length;
                }
                return unescape(document.cookie.substring(c_start, c_end));
            }
        }
        return "";
    }

    let backoff=[1000, 3000];
    let attemptCount = 0;

    function setupStatus() {
        webSocket = new WebSocket("ws://" + hostPort + "/status")
        webSocket.onmessage = function(msg) {
            console.log("websocket to send " + msg + " " + webSocket.readyState);
            DeckDisplay.updateStatus(msg);
        };
        webSocket.onclose = async function() {
            showOverlay("#balladOverlay");
            console.log("WebSocket connection closed " + webSocket.readyState)
            if (attemptCount < backoff.length) {
                let timeToSleep = backoff[attemptCount];
                attemptCount++;
                await sleep(timeToSleep);
                setupStatus();
            }
        }
        webSocket.onopen = function(e) {
            console.log("WebSocket connection open. Asking for status update. " + webSocket.readyState);
            attemptCount = 0;
            window.location="#";
            webSocket.send('update status');

        };
        return webSocket;
    }

    function statusResetRequired(path) {
       if(webSocket.readyState < 2) return false;

       webSocket = setupStatus();
       let deckDisplay = dd_al;
       forEachDeckDisplay(function(value, key, map) {if (key.matches(path)) deckDisplay=value;});
       deckDisplay.reportError("Status restored. Try again!");
       finishRequest(false);
       return true;
       }

    function sendRequest(method, path, onLoadCallback, onErrorCallback) {
        if (statusResetRequired(path)) return;

        let xhttp = new XMLHttpRequest();
        xhttp.addEventListener("load", function(ev) { onLoadCallback(xhttp); });
        xhttp.addEventListener("error", function(ev) {  onErrorCallback(xhttp);   });
        xhttp.open(method, getUrl(path), true);
        //	  xhttp.setRequestHeader("Authorize", "dm9yZGVsOnZvcmRlbA==");
        xhttp.send();
    }

    function get(path, onLoadCallback, onErrorCallback) {
        sendRequest("GET", path, onLoadCallback, onErrorCallback);
    }

    function post(path, onLoadCallback, onErrorCallback) {
        sendRequest("POST", path, onLoadCallback, onErrorCallback);
    }

    function del(path, onLoadCallback, onErrorCallback) {
        sendRequest("DELETE", path, onLoadCallback, onErrorCallback);
    }

    function processActionResponse(xhttp, deckDisplay, successCallback) {
        let requestStatusCode = xhttp.status;

        switch (requestStatusCode) {
            case 200:
                successCallback(deckDisplay, xhttp.responseText)
                updateRequestId(xhttp.getResponseHeader("id"));
                return;
            case 404:
                deckDisplay.reportError("Needs shuffling!");
                break;
            case 409:
                deckDisplay.reportError("Locked!");
            default:
                deckDisplay.reportUnexpectedError(xhttp);
        }
        finishRequest(false);
    }

    function finishRequest(hasMoreDrawingToDo) {
        if(isDrawing) isDrawing=hasMoreDrawingToDo;
        applyStatusForAllDecks();
    }

    function updateRequestId(id) {
        let target = "requestId";
        updateElement(target, false, id);
    }

    function setHistory(history) {
        updateElement("history", false, history);
        createCookie("moveHistory", history, 12);
    }

    function updateHistory(card) {
        let anchorText = new Date().toLocaleTimeString('en-US', {hour12: false });
        let sector = card.deck.navPath.replace("/", "");
        sector = sector.replace("/nav", "");
        sector = capitalizeFirstLetter(sector);
        anchorText += " " + sector + "-" + card.action;
        let item = card.getAnchor(anchorText);
        let history = "<li>" + item + "</li>" + document.getElementById("history").innerHTML;
        setHistory(history);
    }

    function forEachDeckDisplay(valueKeyMap) {
        dds.forEach(valueKeyMap);
    }

    function disableDrawButtons() {
        forEachDeckDisplay(function(value, key, map) {
            value.disableDrawCardButton(true);
        });
    }

    function applyStatusForAllDecks() {
        forEachDeckDisplay(function(value, key, map) {
            value.applyStatus();
        });
    }

    function displayNavCard(deckDisplay, responseText) {
        let card = Card.FromJson(deckDisplay.deck, responseText);
        let cardDisplay = new CardDisplay(card);
        cardDisplay.display(500, 500, false);
        deckDisplay.updateResponse("&nbsp;");
        updateHistory(card);
    }

    function justDisplayResponse(deckDisplay, responseText) {
        forEachDeckDisplay(function(value, key, map) {value.updateResponse("&nbsp;");});
        deckDisplay.updateResponse(responseText);
    }

    function displayResponseInOverlay(deckDisplay, responseText) {
        let html = "<table>";
        let cards = JSON.parse(responseText);
        for (let i = 0; i < cards.length; ++i) {
            let cardCount = cards[i];
            let card = new Card(deckDisplay.deck, cardCount.key);
            html += "<tr><td class='align_right'>" + card.getAnchor(card.action) +
                "</td><td class='align_right px80wide'>" + cardCount.value + "&nbsp;</td></tr>";
        }
        html += "</table>";
        updateElement(deckDisplay.specAreaId, false, html);
    }

    function createOnSendErrorCallback(deckDisplay) {
        return function(xhttp) {
            deckDisplay.reportUnexpectedError("Send failed.");
            finishRequest();
        };
    }

    function createOnSendLoadCallback(deck, successCallback) {
            return function(xhttp) {
                return processActionResponse(xhttp, deck, successCallback);
            };
        }
        //TODO put drawCard et. al on DeckDisplay when i figure out private functions (which most of these shoudl be)
        //     or is this now modules?
    function drawCard(deckDisplay) {
            let deck = deckDisplay.deck;
            isDrawing = true;
            disableDrawButtons();
            deckDisplay.displayCardBack();
            get(deck.navPath, createOnSendLoadCallback(deckDisplay, displayNavCard), createOnSendErrorCallback(
                deckDisplay));
    }

    function lock(deckDisplay) {
        post(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function unlock(deckDisplay) {
        del(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
            createOnSendErrorCallback(deckDisplay));
    }

    function shuffle(deckDisplay) {
        if (confirm("Are you sure?") == true) shuffleDontAsk(deckDisplay);
    }

    function shuffleDontAsk(deckDisplay) {
        post(deckDisplay.deck.navPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse),
        createOnSendErrorCallback(deckDisplay));
    }

    function resetAll() {
        if (confirm("Are you *really* sure?") == true)
            forEachDeckDisplay(function(value, key, map) {  shuffleDontAsk(value);  });
    }

    function describe(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function showWebsocketState() {
        console.log("ws " + webSocket.readyState);
    }

    function clearHistory() {
        //webSocket.close();
        setHistory("");
    }

    function composeDescription(deckDisplay) {
        get(deckDisplay.deck.specPath, createOnSendLoadCallback(deckDisplay, displayResponseInOverlay),
            createOnSendErrorCallback(deckDisplay));
    }

    function debounce(fun, mil) {
        var timer;
        return function() {
            clearTimeout(timer);
            timer = setTimeout(function() {
                fun();
            }, mil);
        };
    }

    function showOverlay(hrefToShow) {
        debounce(function() {
            document.querySelector('body').classList.add('noscroll');
            document.querySelector('html').classList.add('noscroll');
            location.href = hrefToShow;
        }, 200).call();
    }

    function restoreScrolling() {
                document.querySelector('body').classList.remove('noscroll');
                document.querySelector('html').classList.remove('noscroll');
    }

    function restoreScrollingAfterClosingOverlays() {
         let anchors = document.getElementsByClassName("close");
         for(let i = 0; i < anchors.length; i++) {
            let anchor = anchors[i];
            anchor.addEventListener("click",restoreScrolling(),false);
         }

         window.addEventListener('popstate', function(event) {
          let fragment = document.location.hash;
          if (""==fragment) restoreScrolling();
        }, true);

    }

    window.onload = function(e) {
        let history = getCookie("moveHistory");
        updateElement("history", false, history);
        //TODO do something about repeating over all decks
        forEachDeckDisplay(function(value, key, map) {
            composeDescription(value);
        });
        restoreScrollingAfterClosingOverlays();
    };

    </script>
</head>

<body>
<div>

<table id="deckTable">
    <tr>
        <td id="/nav/card" colspan="3"><img src="/SerenityLogo.png" class='external_image logo_image'>
        </td>
    </tr>
    <tr id="drawActions">
        <td>
            <div id="/alliance/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_al)"/>
        </td>
        <td>
            <div id="/border/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_bo)"/>
        </td>
        <td>
            <div id="/rim/nav/drawBtn" class="mediumCard" onclick="drawCard(dd_ri)"/>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/status"></span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/status"></span></p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/requestResult">&nbsp;</span>
            </p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/requestResult">&nbsp;</span>
            </p>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_al)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_bo)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/lockBtn" class="button_with_text" type="button" onclick="lock(dd_ri)">Lock Deck
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_al)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/unlockBtn" class="button_with_text top_margin" type="button"
                    onclick="unlock(dd_bo)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/unlockBtn" class="button_with_text top_margin" type="button" onclick="unlock(dd_ri)">
                Unlock Deck
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/shuffleBtn" class="button_with_text top_margin " type="button"
                    onclick="shuffle(dd_al)">Shuffle
            </button>
        </td>
        <td>
            <button id="/border/nav/shuffleBtn" class="button_with_text top_margin" type="button"
                    onclick="shuffle(dd_bo)">Shuffle
            </button>
        </td>
        <td>
            <button id="/rim/nav/shuffleBtn" class="button_with_text top_margin" type="button" onclick="shuffle(dd_ri)">
                Shuffle
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/alliance/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/border/nav/specOverlay');">Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/describeBtn" class="button_with_text top_margin" type="button"
                    onclick="showOverlay('#/rim/nav/specOverlay');">Deck
            </button>
        </td>
    </tr>

</table>

<br>

    <button id="resetAllBtn" class="button_with_text top_margin" type="button" onclick="resetAll()">Shuffle All
    </button>
    <br>
<button id="historyBtn" class="button_with_text top_margin" type="button" onclick="clearHistory()">Clear History
</button>
<h1>History</h1>
<ol start="0" class="less_on_top"><span id="history"></span>
</ol>
    <p>Request id: <span id="requestId"></span></p>
</div>


<section>
    <div id="/alliance/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/alliance/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="/border/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/border/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="/rim/nav/specOverlay" class="overlay">
        <div class="popup">
            <h1>Cards</h1>
            <a class="close" href="#">&#10006;</a>
            <div id="/rim/nav/spec" class="content"></div>
        </div>
    </div>
    <div id="balladOverlay" class="overlay to-the-black">
        <div id="balladPopup" class="popup to-the-black">
            <h1 class="to-the-black">Ballad of Serenity<br>&emsp;by Sonny Rhodes</h1>
            <a class="close to-the-black" onclick="setupStatus()" href="#">&#10006;</a>
            <div id="balladOverlayDiv" class="content to-the-black">
                Take my love.<br>
                Take my land.<br>
                Take me where I cannot stand.<br>
                I don't care,<br>
                I'm still free.<br>
                You can't take the sky from me.<br>
                <br>
                Take me out to the black.<br>
                Tell em I ain't comin' back.<br>
                Burn the land<br>
                And boil the sea.<br>
                You can't take the sky from me.<br>
                <br>
                There's no place I can't be<br>
                Since I found Serenity.<br>
                But you can't take the sky from me.<br>

            </div>
        </div>
    </div>
</section>
</body>

</html>
