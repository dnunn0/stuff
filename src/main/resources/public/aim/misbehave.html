<!DOCTYPE html>
<html>
<head>
    <style>

         h1 {font-size: 3.5rem;}
         p {font-size: 3rem;}
         a {font-size: 3rem;}
         ol {font-size: 3rem;margin-bottom: 0.5rem;margin-left:0.5rem}
         td {text-align: center;}


        img {
            padding: 0;
            margin: 0;
            border:0;
        }


         /* table {width:100%;margin: 2.5rem 0% 0% 0%;border: 1px solid black;} */
          table {width:1200px;margin: 2.5rem 0% 0% 0%;}

         .less_on_top {margin-top: -10px;}
         .external_image {
           -moz-force-broken-image-icon: 1;
         }
          .logo_image {
             height: 1040px;width:1100px;
         }
         .large_card_image {
           height: 1040px;width: 715px;
         }
         .button_image {
            height: 480px;
            width: 330px;
         }
        .button_with_image {
            width:335px;
            padding: 0 0 0 0;
            border: none;
            background: none;
            margin: 0 100px 0 0;
         }
         button.button_with_image:disabled {
              opacity: 0.3;
        }
         .button_with_text_no_top_margin {
            font-size: 2.5rem;
         }
         .button_with_text {
            margin: 2.5rem 0rem 0rem 0rem;
            font-size: 2.5rem;
         }


    </style>
    <title>Firefly</title>
    <script>

        let hostPort = location.hostname + ":" + location.port;
        let isDrawing=false;

        setupStatus();
        let deck_al=new Deck("/alliance/nav");
        let deck_bo=new Deck("/border/nav");
        let deck_ri=new Deck("/rim/nav");
        let decks = new Map();
        decks.set("/alliance/nav", deck_al);
        decks.set("/border/nav", deck_bo);
        decks.set("/rim/nav", deck_ri);

        let dd_al = new DeckDisplay(deck_al);
        let dd_bo = new DeckDisplay(deck_bo);
        let dd_ri = new DeckDisplay(deck_ri);
        let dds = new Map();
        dds.set(deck_al, dd_al);
        dds.set(deck_bo, dd_bo);
        dds.set(deck_ri, dd_ri);


    function Deck(navPath) {
       this.navPath=navPath;
       this.navLockPath=navPath+"/lock";
       this.remainingCardsCount = -1;
       this.discardsCount=-1;
       this.isLocked=false;
       this.hasCards=false;
       this.nextDrawDisabledStatus=false;
       this.shouldShuffle=false;
    }
    function FindAndUpdateDeckFrom(statusJsonString) {
        let statusj=JSON.parse(statusJsonString);
	    let deckName = statusj.source;
	    let deck=decks.get(deckName);

        deck.remainingCardsCount=statusj.remainingCardsCount;
        deck.discardsCount=statusj.discardsCount;
        deck.isLocked=statusj.isLocked;
        deck.hasCards=deck.remainingCardsCount > 0;
        deck.nextDrawDisabledStatus=!deck.hasCards || deck.isLocked;
        deck.shouldShuffle=!(deck.hasCards || deck.isLocked);
        return deck;
    }

	function Card(deck, action) {
	    this.deck=deck;
	    this.action=action;
	}
	function CardFromJson(deck, cardJsonString) {
	    let cardj = JSON.parse(cardJsonString);
	    return new Card(deck, cardj.action);
	}

	Card.prototype.getUrl = function () {
        let cardName = this.action.replace(/[^a-zA-Z]/g, "")+".png";
	    cardName = startWithSlash(cardName);
	    return "http://"+hostPort+ this.deck.navPath + "Card" + cardName;
	}

	function DeckDisplay(deck) {
	   this.deck = deck;
	   this.responseStatusArea=deck.navPath+"/requestResult";
	   this.drawBtnId=this.deck.navPath +"/drawBtn";
	   this.shuffleBtnId=this.deck.navPath +"/shuffleBtn";
	   this.unlockBtnId=this.deck.navPath +"/unlockBtn";
	   this.statusId=this.deck.navPath+"/status";
	}
	DeckDisplay.prototype.reportError = function(message) {
	    updateElement(this.responseStatusArea, true, message);
	}
	DeckDisplay.prototype.reportUnexpectedError = function(xhttp) {
		let result = "Unexpected error: ReadyState, status, text: " + xhttp.readyState + "- " + xhttp.status + "-" + xhttp.statusText + ".";
	    this.reportError(result);
	}
	DeckDisplay.prototype.updateResponse = function(message) {
	    updateElement(this.responseStatusArea, false, message);
    }
    DeckDisplay.prototype.disableDrawCardButton = function(newState) {
        let control = document.getElementById(this.drawBtnId);
        control.disabled = newState;
    }
    DeckDisplay.prototype.applyNextDrawDisabledStatus = function() {
    //TODO how to make private methods (and then can make disable(id) private too)
        this.disableDrawCardButton(this.deck.nextDrawDisabledStatus);
    }
    DeckDisplay.prototype.applyStatus = function() {
        if(!isDrawing) this.applyNextDrawDisabledStatus();
        document.getElementById(this.shuffleBtnId).disabled = !this.deck.shouldShuffle;
        document.getElementById(this.unlockBtnId).disabled = !this.deck.isLocked;
    }
    DeckDisplay.prototype.reportStatus = function() {
	  let result = this.deck.remainingCardsCount +"/" + (this.deck.remainingCardsCount+this.deck.discardsCount);
	  result += "&nbsp;(" + this.deck.discardsCount +")";
	  updateElement(this.statusId, false, result);
	}
    DeckDisplay.prototype.displayCardBack = function() {
	  let card = new Card(this.deck, "back");
      let cardDisplay = new CardDisplay(card);
      cardDisplay.display(0, 0, true);
    }

	function CardDisplay(card) {
	    this.card = card;
	}
	CardDisplay.prototype.display = function(teaseTimeMs, postDisplayWaitTimeMs, hasMoreDrawingToDo) {
	  let cardUrl=this.card.getUrl();
	  let altText=this.card.action;
      let qm = quoteMarkFor(altText);
      let newHtml = "<img class='external_image large_card_image' src='" + cardUrl +"'"
                + " alt="+qm+altText+qm
                +"/>";
      let startOfWait = (new Date()).getTime();
	  preloadImage(cardUrl, async function() {
	      let endOfWait = (new Date()).getTime();
	      let timeToSleep = Math.max(0, teaseTimeMs - (endOfWait - startOfWait));
          await sleep(timeToSleep);

          updateElement("/nav/card", false, newHtml);
          await sleep(Math.max(0, postDisplayWaitTimeMs));
          isDrawing=hasMoreDrawingToDo;
          applyStatusForAllDecks();
      });
    }



	function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

	function quoteMarkFor(text) {
	    let qm = '"';
	    if (text.includes(qm)) qm = "'";
	    return qm;
	 }

    function sleep(timeToSleepMs) {
       return new Promise(resolve => setTimeout(resolve, timeToSleepMs));
   }

	function preloadImage(url, callback) {
        let img=new Image();
        img.src=url;
        img.onload = callback;
    }

    function startWithSlash(text) {
      if ((text) && (!text.startsWith("/"))) text ="/"+text;
      return text;
    }

	function getUrl(path) {
	    path = startWithSlash(path);
	    return "http://"+hostPort+ path;
	}

	function updateElement(targetId, addEmphasis, newHtml) {
	  if (addEmphasis) newHtml = "<font color='red'>" + newHtml + "</font>";
	  document.getElementById(targetId).innerHTML = newHtml;
	}

    function setupStatus() {
        let statusUrl="ws://" + hostPort + "/status";
        let webSocket = new WebSocket(statusUrl);
        webSocket.onmessage = function (msg) { updateStatus(msg); };
        webSocket.onclose = function () { console.log("WebSocket connection closed ") }
        webSocket.onopen = function(e) {
            console.log("WebSocket connection open. Asking for status update. ");
            webSocket.send('update status');
        };
    }

	function sendRequest(method, path, onLoadCallback, onErrorCallback) {
	  let xhttp = new XMLHttpRequest();
	  xhttp.addEventListener("load", function(ev){onLoadCallback(xhttp); });
	  xhttp.addEventListener("error", function(ev){onErrorCallback(xhttp);});

	  xhttp.open(method, getUrl(path), true);
//	  xhttp.setRequestHeader("Authorize", "dm9yZGVsOnZvcmRlbA==");
	  xhttp.send();
	}

	function get(path, onLoadCallback, onErrorCallback) {
	  sendRequest("GET", path, onLoadCallback, onErrorCallback );
	}

	function post(path, onLoadCallback, onErrorCallback) {
	  sendRequest("POST", path, onLoadCallback, onErrorCallback);
    }

	function del(path, onLoadCallback, onErrorCallback) {
	  sendRequest("DELETE", path, onLoadCallback,onErrorCallback);
	}

	function processActionResponse(xhttp, deckDisplay, successCallback) {

		switch (xhttp.status) {
		  case 200:
			successCallback(deckDisplay, xhttp.responseText)
		    updateRequestId(xhttp.getResponseHeader("id"));
			break;
		  case 404:
			deckDisplay.reportError("Needs shuffling!");
			break;
		  case 409:
			deckDisplay.reportError("Locked!");
			break;
		  default:
			deckDisplay.reportUnexpectedError(xhttp);
		}
	}

	function updateRequestId(id) {
		let target = "requestId";
        updateElement(target, false, id);
	}

	function updateHistory(card) {
	    let anchorText = card.deck.navPath.replace("/","");
	    anchorText = anchorText.replace("/nav", "");
	    anchorText = capitalizeFirstLetter(anchorText);
	    anchorText += "-"+card.action;
	    let cardUrl=card.getUrl();
		let item = "<a href='"+cardUrl+"' target='_blank'>"+ anchorText + "</a>";
		updateElement("history", false, "<li>"+item+"</li>" + document.getElementById("history").innerHTML);
	}

    function forEachDisplayDeck(valueKeyMap){
         dds.forEach(valueKeyMap);
    }
    function disableDrawButtons() {
        forEachDisplayDeck(function(value, key, map) {
            value.disableDrawCardButton(true);
        });
    }
    function applyStatusForAllDecks() {
        forEachDisplayDeck(function(value, key, map) {
            value.applyStatus();
        });
    }

	function displayNavCard(deckDisplay, responseText) {
	  let card = CardFromJson(deckDisplay.deck, responseText);
	  let cardDisplay = new CardDisplay(card);
	  cardDisplay.display(400, 700, false);
      deckDisplay.updateResponse("&nbsp;");
	  updateHistory(card);
	}

	function justDisplayResponse(deckDisplay, responseText) {
	  deckDisplay.updateResponse(responseText);
	}

    function createOnSendErrorCallback(deckDisplay) {
        return function(xhttp){deckDisplay.reportUnexpectedError("Send failed.");};
    }

    function createOnSendLoadCallback(deck, successCallback) {
        return function(xhttp){return processActionResponse(xhttp, deck, successCallback);};
    }


	function drawCard(deckDisplay) {
	  let deck=deckDisplay.deck;
	  isDrawing=true;

       disableDrawButtons();
        deckDisplay.displayCardBack();
	  get(deck.navPath, createOnSendLoadCallback(deckDisplay, displayNavCard), createOnSendErrorCallback(deck));
	}

//TODO move lock, etc. into DeckDisplay? (Deck?--lots is UI related...)
	function lock(deckDisplay) {
	  post(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse), createOnSendErrorCallback(deckDisplay));
	}

	function unlock(deckDisplay) {
	  del(deckDisplay.deck.navLockPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse), createOnSendErrorCallback(deckDisplay));
	}

	function shuffle(deckDisplay) {
	  if(confirm("Are you sure?")==true)
	     post(deckDisplay.deck.navPath, createOnSendLoadCallback(deckDisplay, justDisplayResponse), createOnSendErrorCallback(deckDisplay));
	}


	function clearHistory() {
		updateElement("history", false, "");
	}

    function getPageUrl() {
        return document.location.toString();
    }

    function updateStatus(msg) {
	  let deck=FindAndUpdateDeckFrom(msg.data);
	  let displayDeck=dds.get(deck);
	  displayDeck.reportStatus();
      displayDeck.applyStatus();
    }


	window.onload = function(e) {
	};

	;



    </script>
</head>

<body>
<table>
    <tr>
        <td><span id="/nav/card"><img src="/SerenityLogo.png" class='external_image logo_image'></span><br></td>
    </tr>
</table>

<table>
    <tr id="drawActions">
        <td>
            <button class="button_with_image" id="/alliance/nav/drawBtn" type="button"
                    onclick="drawCard(dd_al)">
                <img src="/alliance/navCard/back.png" -alt='Request Alliance Nav card'
                     class="external_image button_image"/>
            </button>
        </td>
        <td>
            <button class="button_with_image" id="/border/nav/drawBtn" type="button"
                    onclick="drawCard(dd_bo)">
                <img src="/border/navCard/back.png" -alt='Request Border Nav card' class="external_image button_image"/>
            </button>
        </td>
        <td>
            <button class="button_with_image" id="/rim/nav/drawBtn" type="button"
                    onclick="drawCard(dd_ri)">
                <img src="/rim/navCard/back.png" -alt='Request Rim Nav card' class="external_image button_image"/>
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/status"></span>&emsp;&emsp;</p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/status"></span>&emsp;&emsp;</p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/status"></span>&emsp;&emsp;</p>
        </td>
    </tr>
    <tr>
        <td>
            <p class="less_on_top"><span id="/alliance/nav/requestResult">&nbsp;</span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/border/nav/requestResult">&nbsp;</span></p>
        </td>
        <td>
            <p class="less_on_top"><span id="/rim/nav/requestResult">&nbsp;</span></p>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="lock(dd_al)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="lock(dd_bo)">Lock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/lockBtn" class="button_with_text_no_top_margin" type="button"
                    onclick="lock(dd_ri)">Lock Deck
            </button>
        </td>
    </tr>
    <tr>
        <td>
            <button id="/alliance/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="unlock(dd_al)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/border/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="unlock(dd_bo)">Unlock Deck
            </button>
        </td>
        <td>
            <button id="/rim/nav/unlockBtn" class="button_with_text" type="button"
                    onclick="unlock(dd_ri)">Unlock Deck
            </button>
        </td>
    </tr>

    <tr>
        <td>
            <button id="/alliance/nav/shuffleBtn" class="button_with_text" type="button"
                    onclick="shuffle(dd_al)">Shuffle
            </button>
        </td>
        <td>
            <button id="/border/nav/shuffleBtn" class="button_with_text" type="button"
                    onclick="shuffle(dd_bo)">Shuffle
            </button>
        </td>
        <td>
            <button id="/rim/nav/shuffleBtn" class="button_with_text" type="button"
                    onclick="shuffle(dd_ri)">
                Shuffle
            </button>
        </td>
    </tr>

</table>

<br>


<button id="historyBtn" class="button_with_text" type="button" onclick="clearHistory()">Clear History</button>
<h1>History</h1>
<ol start="0" class="less_on_top"><span id="history"></span></ol>
</p>
<p>Request id: <span id="requestId"/><br></p>


</body>
</html>

